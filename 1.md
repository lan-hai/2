# 后端

## Take it easy

1. 我认为联创就是联合创造，是大家一起创造一个项目，我觉得能加入联创的都是大佬，希望能和这样的人交流学习，我个人也对创造自己的项目保有极大兴趣。

2. 我现在对未来还比较迷茫，但是我觉得我应该先探索一下未来的道路，多加入一些组织，多认识一些人，多学一些知识，在这个过程中完善自己的规划

3. 刚开始学，后端就是通过编程语言编写的逻辑代码处理前端发送的用户请求，并且处理数据，再返回结果。前端是表面的界面与交互，而后端就是背后的逻辑与数据。

4. 无

---

## 可爱的C

1.c



     #include<stdlib.h>
    #include<stdio.h>

    int a = 3;
    int*p = &a;
    printf(%p/n,p);
    int main() {
    int*dynamic_arr = (int*)malloc(5 * sizeof(int));
    
    if(dynamic_arr == NULL) {
        printf("内存分配失败!\n");
        return 1;
    }
    
    for(int i = 0; i < 5; i++) {
        dynamic_arr[i] = i * 10;
    }
    
  
    for(int i = 0; i < 5; i++) {
        printf("dynamic_arr[%d] = %d\n", i, dynamic_arr[i]);
    }
    
    
    free(dynamic_arr);
    dynamic_arr = NULL;  
    return 0;
     }

2. 不能，因为这样定义的字符串储存在常量区，无法修改

3. 有的兄弟


       int main (void )
       {

       int a = 1,b = 2;
   
       a =a ^ b;
   
       b =b ^ a;
       a =a ^ b;
       return 0;
        }


4.  A：八字节
 
    B：12字节


5.
  

      #include <stdio.h>

      void print_hex(int num) {
    
      if (num == 0) {
        putchar('0');
        return;
      }

    
      unsigned int n = (unsigned int)num;
    
    
      char hex_digits[] = "0123456789ABCDEF";
    
    
      int started = 0; 

    
      for (int i = 7; i >= 0; i--) {
        
        unsigned int digit = (n >> (i * 4)) & 0xF;
        
        
        if (digit == 0 && !started) {
            continue; 
        }
        
    
        started = 1;
        putchar(hex_digits[digit]);
       }


 
       int main() {
 
        int test_numbers[] = {108, 0, -108, 255, 0x7FFFFFFF, 0x80000000};
        int count = sizeof(test_numbers) / sizeof(test_numbers[0]);

       for (int i = 0; i < count; i++) {
        int num = test_numbers[i];
        printf("十进制 %d 的十六进制表示为: ", num);
        print_hex(num);
        printf("\n");
        }

       return 0;
                }

---

# 严肃的数据库

## 问题一

1. 持久性
2. 原子性 
3. 一致性
4. 隔离性
5. 数据结构化
6. 共享性低冗余
7. 数据独立性
8. 由DBMS统一管理

数据库能够高效地存储和检索数据。通过结构化的方式存储数据，用户可以快速访问和查询所需信息。例如，搜索引擎如百度和谷歌利用数据库技术实现快速搜索。

数据库可以确保数据的一致性和完整性。通过避免重复数据和实施完整性约束，数据库能够减少数据冗余并防止数据错误，从而提高数据的可靠性。

数据库提供了强大的安全性。通过用户权限管理和数据加密等措施，数据库可以防止未经授权的访问。例如，员工的工资信息可以通过数据库设置权限，仅允许特定人员查看。

数据库支持数据共享和协作。多个用户和应用程序可以同时访问和修改数据，从而提高工作效率并减少数据不一致的风险。

数据库具有持久性，能够长期保存数据。即使系统崩溃或重启，数据仍然不会丢失，这确保了数据的稳定性和可用性。

数据库支持复杂的数据分析。通过数据挖掘和分析技术，可以从数据库中提取有价值的信息。例如，超市可以根据销售数据分析商品的销售趋势，从而优化库存管理。

数据库管理系统（DBMS）提供了强大的数据操作能力。用户可以通过SQL等查询语言轻松实现数据的插入、更新、删除和查询，满足各种复杂的业务需求。

## 问题二

~还在学~

## 问题三

~还在了解~

（笔试时间快到了，才了解到SQL是什么，以及relational database 的一些内容，有一说一那个roadmap真的好）

---

# 可靠的git

1. 两个分支中存在相同文件，合并时发生冲突。

解决：      

    git checkout --ours text2.txt

    git add text2.txt

    
 or:   
 
    git checkout --theirs text2.txt
    git add text2.txt

2.

       git switch dev-B
      git cherry-pick <commit-hash>

# 精妙的计算机网络

1. 据我所知，域名是方便我们记住的的一个代号，计算机无法理解，而ip地址以计算机可以理解的形式存在，是一个明确的坐标。之所以要解析就是为了翻译给计算机看。

至于DNS，首先当你输入了域名并回车，浏览器会先检查缓存内是否存在相应的IP地址。有则使用，无则进入下一步。

下一步：调用操作系统进行缓存查询。万一又没有进入下下一步。

下下一步：请求本地DNS服务器，寻找缓存。万一又又没有进入下下下一步。

下下下一步：查询：

 1.1 根域名服务器

 1.2 顶级域名服务器

 1.3 权威域名服务器

 最终拿到ip，按上面步骤一步步返回值浏览器。建立连接。
 

2. 方法：

针对IP，dns，域名，内容的识别与阻断。如ip封锁，dns污染，端口封锁，server name indication , 内容过滤。长城。

解决方法：

2.1 代理服务器，隐藏ip

2.2 vpn，加密

2.3 改DNS，绕过dns污染


3. 获得公网IP

3.1 云服务器

3.2 内网穿透

3.3 申请公网IP

4.有的兄弟

当**连接时**，client先设置SYN标志位1，然后选择一个序列号，这里定为x。

server呢，接收到这个之后，设置SYN和ACK标志位1，然后选择一个序列号，定为y确认号设为x+1

client接收到之后再发一个确认，ACK1，序列号x+1，确认号y+1.

当**断开时**，client呢接着发报，设置FIN为1，然后序列号

serverACK1，然后确认号为序列号+1

然后反过来重复以上步骤。

至于为什么多一次，我的理解是其实建立/断开连接只需要两次，之所以要三次是因为防止已失效的连接请求报文突然又传到了服务器，从而导致错误

而因为TCP连接是全双工的，每个方向都需要单向断开，所以要四次。

5.http是客户端和服务器之间请求和应答的协议，大概就是client发送HTTP请求，然后客户端给予HTTP响应巴拉巴拉的。大概用于互联网通信，你输入网址到打开网页，就是请求与响应的过程。HTTPS就是加密的HTTP。

~这个代码超纲了QAQ~

---

#有趣的实践

1.（在写这个题之前几乎不了解）

function calling：让大语言模型具备调用外部工具、函数或API的能力

RAG：信息检索

REACT:推理加行动，一步步解决复杂问题

AI Agent：上述技术的集大成者，一个很牛逼的AI系统。

langchain：搭建上述功能的工具

mcp：通信协议，用于llm与数据库，工具的交互。

自用ai：deepseek，copilot，（主要是这两个）

API:（上次看到这个还是steam上的api密匙，用于我go的饰品交易）

Application Programming Interface，应用程序编程接口，不同软件应用程序之间通信的协议规则。

没怎么用过这个

（流式传输吗，才知道是什么）（不会）

2.

进程包含线程包含协程。

进程：资源分配的基本单位

线程：CPU调度的基本单位

协程：用户态的轻量级线程

剩下的太复杂力

2. 4. 芝士什么，看不懂，C语言学习ing

5.6. 虽然不会go，但我是go学长。

7.8. 抽象

---

#益智休闲游戏
（益智在哪，休闲在哪）看我llm大法

a>c

n-1

deepseek用反证法先证必要性在证充分性
太难了这个













